package org.numenta.nupic.encoders;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.numenta.nupic.research.Connections;
import org.numenta.nupic.util.ArrayUtils;
import org.numenta.nupic.util.MinMax;
import org.numenta.nupic.util.Tuple;

public abstract class Encoder {
	/** Value used to represent no data */
	public static final double SENTINEL_VALUE_FOR_MISSING_DATA = Double.NaN;
	
	
	/**
	 * Encodes inputData and puts the encoded value into the numpy output array,
     * which is a 1-D array of length returned by {@link Connections#getW()}.
	 *
     * Note: The numpy output array is reused, so clear it before updating it.
     * 
	 * @param c
	 * @param inputData Data to encode. This should be validated by the encoder.
     * @param output 1-D array of same length returned by {@link Connections#getW()}
     * 
	 * @return
	 */
	protected abstract int[] encodeIntoArray(Connections c, double inputData, int[] output);
	
	/**
	 * Convenience wrapper for {@link #encodeIntoArray(Connections, double, int[])}
	 *  
     * @param c				the memory
	 * @param inputData		the input scalar
	 * @return	an array with the encoded representation of inputData
	 */
	public int[] encode(Connections c, double inputData) {
		int[] output = new int[c.getN()];
		encodeIntoArray(c, inputData, output);
		return output;
	}
	
	/**
	 * Takes an encoded output and does its best to work backwards and generate
     * the input that would have generated it.
	 *
     * In cases where the encoded output contains more ON bits than an input
     * would have generated, this routine will return one or more ranges of inputs
     * which, if their encoded outputs were ORed together, would produce the
     * target output. This behavior makes this method suitable for doing things
     * like generating a description of a learned coincidence in the SP, which
     * in many cases might be a union of one or more inputs.
	 * 
     * If instead, you want to figure the *most likely* single input scalar value
     * that would have generated a specific encoded output, use the topDownCompute()
     * method.
	 * 
     * If you want to pretty print the return value from this method, use the
     * decodedToStr() method.
	 *
	 *************
	 * OUTPUT EXPLAINED:
	 * 
     * fieldsMap is a {@link Map} where the keys represent field names
     * (only 1 if this is a simple encoder, > 1 if this is a multi
     * or date encoder) and the values are the result of decoding each
     * field. If there are  no bits in encoded that would have been
     * generated by a field, it won't be present in the Map. The
     * key of each entry in the dict is formed by joining the passed in
     * parentFieldName with the child encoder name using a '.'.
	 * 
     * Each 'value' in fieldsMap consists of a {@link Tuple} of (ranges, desc), 
     * where ranges is a list of one or more {@link MinMax} ranges of
     * input that would generate bits in the encoded output and 'desc'
     * is a comma-separated pretty print description of the ranges. 
     * For encoders like the category encoder, the 'desc' will contain 
     * the category names that correspond to the scalar values included 
     * in the ranges.
	 * 
     * The fieldOrder is a list of the keys from fieldsMap, in the
     * same order as the fields appear in the encoded output.
     * 
     * Example retvals for a scalar encoder:
	 *
     *   {'amount':  ( [[1,3], [7,10]], '1-3, 7-10' )}
     *   {'amount':  ( [[2.5,2.5]],     '2.5'       )}
 	 *
     * Example retval for a category encoder:
	 *
     *   {'country': ( [[1,1], [5,6]], 'US, GB, ES' )}
	 *
     * Example retval for a multi encoder:
	 *
     *   {'amount':  ( [[2.5,2.5]],     '2.5'       ),
     *   'country': ( [[1,1], [5,6]],  'US, GB, ES' )}
     *    
	 * @param c					the memory
	 * @param encoded      		The encoded output that you want decode
     * @param parentFieldName 	The name of the encoder which is our parent. This name
     *      					is prefixed to each of the field names within this encoder to form the
     *    						keys of the {@link Map} returned.
	 *
     * @returns Tuple(fieldsMap, fieldOrder)
	 */
	@SuppressWarnings("unchecked")
	public Tuple decode(Connections c, int[] encoded, String parentFieldName) {
		Map<String, Tuple> fieldsMap = new HashMap<String, Tuple>();
		List<String> fieldsOrder = new ArrayList<String>();
		
		String parentName = parentFieldName == null || parentFieldName.isEmpty() ? 
			c.getName() : String.format("%s.%s", parentFieldName, c.getName());
		
		List<Tuple> encoders = c.getEncoders();
		int len = encoders.size();
		for(int i = 0;i < len;i++) {
			Tuple threeFieldsTuple = encoders.get(i);
			int nextOffset = 0;
			if(i < len - 1) {
				nextOffset = (Integer)encoders.get(i + 1).get(2);
			}else{
				nextOffset = c.getW();
			}
			
			int[] fieldOutput = ArrayUtils.sub(encoded, ArrayUtils.range((Integer)threeFieldsTuple.get(2), nextOffset));
			
			Tuple result = ((Encoder)threeFieldsTuple.get(1)).decode(c, fieldOutput, parentName);
			
			fieldsMap.putAll((Map<String, Tuple>)result.get(0));
			fieldsOrder.addAll((List<String>)result.get(1));
		}
		
		return new Tuple(2, fieldsMap, fieldsOrder);
	}
	
	/**
	 * Returns this {@code ScalarEncoder}'s description.
	 * @param c
	 * @return
	 */
	public String getDescription(Connections c) {
		return c.getName();
	}
	
	/**
	 * Return a pretty print string representing the return value from decode().
	 * 
	 * @param decodeResults
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public String decodedToStr(Tuple decodeResults) {
		StringBuilder desc = new StringBuilder();
		Map<String, Tuple> fieldsDict = (Map<String, Tuple>)decodeResults.get(0);
		List<String> fieldsOrder = (List<String>)decodeResults.get(1);
		for(String fieldName : fieldsOrder) {
			Tuple ranges = fieldsDict.get(fieldName);
			if(desc.length() > 0) {
				desc.append(", ").append(fieldName).append(":");
			}else{
				desc.append(fieldName).append(":");
			}
			desc.append("[").append(ranges.get(1)).append("]");
		}
		return desc.toString();
	}
}
